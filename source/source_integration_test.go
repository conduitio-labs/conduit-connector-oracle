// Copyright Â© 2022 Meroxa, Inc. & Yalantis
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"hash/fnv"
	"os"
	"strings"
	"testing"

	"github.com/conduitio-labs/conduit-connector-oracle/repository"
	"github.com/conduitio-labs/conduit-connector-oracle/source/config"
	"github.com/conduitio/conduit-commons/opencdc"
	sdk "github.com/conduitio/conduit-connector-sdk"
	"github.com/matryer/is"
)

const createTableQueryFmt = `
CREATE TABLE %s (
  id NUMBER GENERATED by default on null as IDENTITY, 
  name VARCHAR2(30) NOT NULL, 
  age NUMBER, 
  is_active NUMBER(1, 0), 
  PRIMARY KEY (id)
)
`

func TestSource_noTable(t *testing.T) {
	var (
		cfg = prepareConfig(t)
		is  = is.New(t)
	)

	repo, err := repository.New(cfg[config.ConfigUrl])
	is.NoErr(err)
	defer repo.Close()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	src := NewSource()

	err = src.Configure(ctx, cfg)
	is.NoErr(err)

	err = src.Open(ctx, nil)
	is.True(strings.Contains(err.Error(), "table or view does not exist"))

	cancel()
}

func TestSource_emptyTable(t *testing.T) {
	var (
		cfg = prepareConfig(t)
		is  = is.New(t)
	)

	repo, err := repository.New(cfg[config.ConfigUrl])
	is.NoErr(err)
	defer repo.Close()

	// create table
	_, err = repo.DB.Exec(fmt.Sprintf(createTableQueryFmt, cfg[config.ConfigTable]))
	is.NoErr(err)

	defer func() {
		err = dropTables(repo, cfg[config.ConfigTable])
		is.NoErr(err)
	}()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	src := NewSource()

	err = src.Configure(ctx, cfg)
	is.NoErr(err)

	err = src.Open(ctx, nil)
	is.NoErr(err)

	_, err = src.Read(ctx)
	is.Equal(err, sdk.ErrBackoffRetry)

	cancel()

	err = src.Teardown(context.Background())
	is.NoErr(err)
}

func TestSource_keyColumns(t *testing.T) {
	var (
		is  = is.New(t)
		cfg = map[string]string{
			config.ConfigUrl:            getURL(t),
			config.ConfigTable:          fmt.Sprintf("CONDUIT_SRC_TEST_%s", randString(6)),
			config.ConfigOrderingColumn: "int_type_2",
			config.ConfigKeyColumns:     "int_type_0",
		}
	)

	repo, err := repository.New(cfg[config.ConfigUrl])
	is.NoErr(err)
	defer repo.Close()

	// create table with two primary keys
	_, err = repo.DB.Exec(fmt.Sprintf(`
CREATE TABLE %s (
  int_type_0 NUMBER(38, 0), 
  int_type_1 NUMBER(38, 0), 
  int_type_2 NUMBER(38, 0), 
  PRIMARY KEY (int_type_0, int_type_1)
)
`, cfg[config.ConfigTable]))
	is.NoErr(err)

	defer func() {
		err = dropTables(repo, cfg[config.ConfigTable])
		is.NoErr(err)
	}()

	// insert row
	_, err = repo.DB.Exec(fmt.Sprintf("INSERT INTO %s VALUES (10, 20, 30)", cfg[config.ConfigTable]))
	is.NoErr(err)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	src := NewSource()

	err = src.Configure(ctx, cfg)
	is.NoErr(err)

	err = src.Open(ctx, nil)
	is.NoErr(err)

	// read records
	record, err := src.Read(ctx)
	is.NoErr(err)
	is.Equal(record.Key, opencdc.StructuredData(map[string]interface{}{"INT_TYPE_0": 10}))

	cancel()

	err = src.Teardown(context.Background())
	is.NoErr(err)
}

func TestSource_keyColumnsPrimaryKeys(t *testing.T) {
	var (
		is  = is.New(t)
		cfg = map[string]string{
			config.ConfigUrl:            getURL(t),
			config.ConfigTable:          fmt.Sprintf("CONDUIT_SRC_TEST_%s", randString(6)),
			config.ConfigOrderingColumn: "int_type_2",
		}
	)

	repo, err := repository.New(cfg[config.ConfigUrl])
	is.NoErr(err)
	defer repo.Close()

	// create table with two primary keys
	_, err = repo.DB.Exec(fmt.Sprintf(`
CREATE TABLE %s (
  int_type_0 NUMBER(38, 0), 
  int_type_1 NUMBER(38, 0), 
  int_type_2 NUMBER(38, 0), 
  PRIMARY KEY (int_type_0, int_type_1)
)
`, cfg[config.ConfigTable]))
	is.NoErr(err)

	defer func() {
		err = dropTables(repo, cfg[config.ConfigTable])
		is.NoErr(err)
	}()

	// insert row
	_, err = repo.DB.Exec(fmt.Sprintf("INSERT INTO %s VALUES (10, 20, 30)", cfg[config.ConfigTable]))
	is.NoErr(err)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	src := NewSource()

	err = src.Configure(ctx, cfg)
	is.NoErr(err)

	err = src.Open(ctx, nil)
	is.NoErr(err)

	// read records
	record, err := src.Read(ctx)
	is.NoErr(err)
	is.Equal(record.Key, opencdc.StructuredData(map[string]interface{}{"INT_TYPE_0": 10, "INT_TYPE_1": 20}))

	cancel()

	err = src.Teardown(context.Background())
	is.NoErr(err)
}

func TestSource_keyColumnsOrderingColumn(t *testing.T) {
	var (
		is  = is.New(t)
		cfg = map[string]string{
			config.ConfigUrl:            getURL(t),
			config.ConfigTable:          fmt.Sprintf("CONDUIT_SRC_TEST_%s", randString(6)),
			config.ConfigOrderingColumn: "int_type_1",
		}
	)

	repo, err := repository.New(cfg[config.ConfigUrl])
	is.NoErr(err)
	defer repo.Close()

	// create table without primary keys
	_, err = repo.DB.Exec(fmt.Sprintf(`
CREATE TABLE %s (
  int_type_0 NUMBER(38, 0), 
  int_type_1 NUMBER(38, 0)
)
`, cfg[config.ConfigTable]))
	is.NoErr(err)

	defer func() {
		err = dropTables(repo, cfg[config.ConfigTable])
		is.NoErr(err)
	}()

	// insert row
	_, err = repo.DB.Exec(fmt.Sprintf("INSERT INTO %s VALUES (10, 20)", cfg[config.ConfigTable]))
	is.NoErr(err)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	src := NewSource()

	err = src.Configure(ctx, cfg)
	is.NoErr(err)

	err = src.Open(ctx, nil)
	is.NoErr(err)

	// read records
	record, err := src.Read(ctx)
	is.NoErr(err)
	is.Equal(record.Key, opencdc.StructuredData(map[string]interface{}{"INT_TYPE_1": 20}))

	cancel()

	err = src.Teardown(context.Background())
	is.NoErr(err)
}

func TestSource_snapshotIsFalse(t *testing.T) {
	var (
		is  = is.New(t)
		cfg = map[string]string{
			config.ConfigUrl:            getURL(t),
			config.ConfigTable:          fmt.Sprintf("CONDUIT_SRC_TEST_%s", randString(6)),
			config.ConfigOrderingColumn: "int_type_0",
			config.ConfigSnapshot:       "false",
		}
	)

	repo, err := repository.New(cfg[config.ConfigUrl])
	is.NoErr(err)
	defer repo.Close()

	// create table without primary keys
	_, err = repo.DB.Exec(fmt.Sprintf(`
CREATE TABLE %s (
  int_type_0 NUMBER(38, 0), 
  int_type_1 NUMBER(38, 0)
)
`, cfg[config.ConfigTable]))
	is.NoErr(err)

	defer func() {
		err = dropTables(repo, cfg[config.ConfigTable])
		is.NoErr(err)
	}()

	// insert row
	_, err = repo.DB.Exec(fmt.Sprintf("INSERT INTO %s VALUES (10, 20)", cfg[config.ConfigTable]))
	is.NoErr(err)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	src := NewSource()

	err = src.Configure(ctx, cfg)
	is.NoErr(err)

	err = src.Open(ctx, nil)
	is.NoErr(err)

	// read record
	_, err = src.Read(ctx)
	is.Equal(err, sdk.ErrBackoffRetry)

	// insert one more row
	_, err = repo.DB.Exec(fmt.Sprintf("INSERT INTO %s VALUES (20, 30)", cfg[config.ConfigTable]))
	is.NoErr(err)

	// read records
	record, err := src.Read(ctx)
	is.NoErr(err)
	is.Equal(record.Key, opencdc.StructuredData(map[string]interface{}{"INT_TYPE_0": 20}))

	cancel()

	err = src.Teardown(context.Background())
	is.NoErr(err)
}

func getURL(t *testing.T) string {
	url := os.Getenv("ORACLE_URL")
	if url == "" {
		t.Skip("ORACLE_URL env var must be set")

		return ""
	}

	return url
}

func prepareConfig(t *testing.T) map[string]string {
	return map[string]string{
		config.ConfigUrl:            getURL(t),
		config.ConfigTable:          fmt.Sprintf("CONDUIT_SRC_TEST_%s", randString(6)),
		config.ConfigKeyColumns:     "id",
		config.ConfigOrderingColumn: "id",
	}
}

func dropTables(repo *repository.Oracle, table string) error {
	_, err := repo.DB.Exec(fmt.Sprintf("DROP TABLE %s", table))
	if err != nil {
		return fmt.Errorf("execute drop table query: %w", err)
	}

	h := fnv.New32a()
	h.Write([]byte(table))
	hash := h.Sum32()

	_, err = repo.DB.Exec(fmt.Sprintf(`
DECLARE tbl_count number;
sql_stmt long;
BEGIN 
SELECT 
  COUNT(*) INTO tbl_count 
FROM 
  dba_tables 
WHERE 
  table_name = 'CONDUIT_TRACKING_%d';
IF(tbl_count <> 0) THEN sql_stmt := 'DROP TABLE CONDUIT_TRACKING_%d';
EXECUTE IMMEDIATE sql_stmt;
END IF;
END;
`, hash, hash))
	if err != nil {
		return fmt.Errorf("execute drop tracking table query: %w", err)
	}

	return nil
}

// generates a random string of length n.
func randString(n int) string {
	b := make([]byte, n)
	rand.Read(b) //nolint:errcheck // does not actually fail

	return strings.ToUpper(hex.EncodeToString(b))
}
